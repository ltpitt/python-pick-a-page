# Legacy Browser Support Implementation Plan

## Overview

This document outlines a clean, maintainable approach to support both modern browsers and legacy browsers (Firefox 52 ESR/Aquafox) in the Pick-a-Page application without polluting the existing codebase.

## Current Architecture Analysis

### Application Type
Pick-a-Page is an **API-first application** with the following architecture:

```
┌─────────────────────────────────────────────────────────────────┐
│                         Flask Backend                            │
├─────────────────────────────────────────────────────────────────┤
│  API Endpoints (JSON)              │  Page Endpoints (HTML)      │
│  ─────────────────────             │  ────────────────────       │
│  GET  /api/stories                 │  GET /                      │
│  GET  /api/story/<filename>        │  GET /play/<story_name>     │
│  POST /api/save                    │                             │
│  POST /api/delete                  │                             │
│  POST /api/compile                 │                             │
│  POST /api/validate                │                             │
│  GET  /api/languages               │                             │
│  GET  /api/translations/<lang>     │                             │
└─────────────────────────────────────────────────────────────────┘
```

### Frontend Components

1. **Editor UI** (`/` route)
   - Jinja2 templates: `base.html`, `index.html`
   - Modern JavaScript: ES2017+ (async/await, classes, arrow functions)
   - CSS: Modern features (CSS variables, flexbox, focus-visible)

2. **Story Player** (`/play/<story_name>` route)
   - Self-contained HTML generated by `HTMLGenerator`
   - Embedded CSS and JavaScript in `templates.py`
   - Uses `const`, arrow functions, `forEach`

### Key Insight

The API layer is **browser-agnostic** - it returns JSON data that can be consumed by any client. The browser-specific code exists only in:

1. Frontend JavaScript files (`/static/js/*.js`)
2. Frontend CSS files (`/static/css/*.css`)
3. Jinja2 templates (`/templates/*.html`)
4. Generated story HTML (`core/templates.py`)

---

## Proposed Solution: API-Driven Client Composition

### Approach

Use the existing API endpoints to serve the same data, but **compose different HTML pages** based on the client type. The server determines the appropriate frontend to serve based on request parameters or User-Agent detection.

### Architecture

```
                          ┌─────────────────────┐
                          │    Flask Backend    │
                          │    (API Layer)      │
                          └─────────┬───────────┘
                                    │
                    ┌───────────────┼───────────────┐
                    │               │               │
              ┌─────▼─────┐   ┌─────▼─────┐   ┌─────▼─────┐
              │  Modern   │   │  Legacy   │   │   API     │
              │  Frontend │   │  Frontend │   │  Clients  │
              │ (ES2017+) │   │   (ES5)   │   │  (JSON)   │
              └───────────┘   └───────────┘   └───────────┘
```

---

## Implementation Options

### Option 1: Query Parameter Based Selection (Recommended)

**Simplest and cleanest approach - no code duplication, explicit control.**

#### How it works:
- Default: Serve modern frontend
- Add `?legacy=1` or `?client=legacy`: Serve legacy frontend
- Same API endpoints, different HTML templates

#### Implementation:

```python
# backend/api/routers/pages.py

@bp.route("/")
def index():
    """Render main page based on client type."""
    client_type = request.args.get('client', 'modern')
    
    if client_type == 'legacy':
        return render_template("index_legacy.html")
    return render_template("index.html")
```

#### File Structure:
```
backend/
├── templates/
│   ├── base.html              # Modern base (existing)
│   ├── base_legacy.html       # Legacy base (new)
│   ├── index.html             # Modern editor (existing)
│   └── index_legacy.html      # Legacy editor (new)
├── static/
│   ├── js/
│   │   ├── *.js               # Modern JS (existing)
│   │   └── legacy/            # Legacy JS (new)
│   │       └── *.js
│   └── css/
│       ├── *.css              # Modern CSS (existing)
│       └── legacy/            # Legacy CSS (new)
│           └── *.css
```

#### Pros:
- ✅ Zero impact on existing modern code
- ✅ Explicit client selection (testable)
- ✅ Easy to maintain separate codebases
- ✅ API remains unchanged
- ✅ Clear separation of concerns

#### Cons:
- ❌ Requires separate template/JS/CSS files

---

### Option 2: User-Agent Based Detection

**Automatic detection, but less explicit control.**

#### How it works:
- Server inspects `User-Agent` header
- Detects Firefox 52 ESR / Aquafox
- Serves appropriate frontend automatically

#### Implementation:

```python
# backend/utils/client_detection.py

def is_legacy_browser(user_agent: str) -> bool:
    """Detect if the browser is a legacy browser."""
    ua_lower = user_agent.lower()
    
    # Firefox 52 ESR detection
    if 'firefox/52' in ua_lower:
        return True
    
    # Aquafox detection
    if 'aquafox' in ua_lower:
        return True
    
    # Generic old Firefox detection (versions < 57)
    import re
    firefox_match = re.search(r'firefox/(\d+)', ua_lower)
    if firefox_match and int(firefox_match.group(1)) < 57:
        return True
    
    return False
```

```python
# backend/api/routers/pages.py

from backend.utils.client_detection import is_legacy_browser

@bp.route("/")
def index():
    """Render main page based on detected client."""
    user_agent = request.headers.get('User-Agent', '')
    
    # Allow override via query parameter
    if request.args.get('client') == 'legacy':
        return render_template("index_legacy.html")
    if request.args.get('client') == 'modern':
        return render_template("index.html")
    
    # Auto-detect
    if is_legacy_browser(user_agent):
        return render_template("index_legacy.html")
    
    return render_template("index.html")
```

#### Pros:
- ✅ Automatic for end users
- ✅ No URL changes needed
- ✅ Supports manual override

#### Cons:
- ❌ User-Agent parsing can be unreliable
- ❌ Harder to test without actual legacy browser

---

### Option 3: Separate Routes (Alternative)

**Different URL paths for different clients.**

#### How it works:
- `/` - Modern frontend
- `/legacy` or `/classic` - Legacy frontend
- Both use same API endpoints

#### Implementation:

```python
@bp.route("/")
def index():
    return render_template("index.html")

@bp.route("/legacy")
def index_legacy():
    return render_template("index_legacy.html")
```

#### Pros:
- ✅ Very clear separation
- ✅ Easy to bookmark either version
- ✅ Simple implementation

#### Cons:
- ❌ Users need to know which URL to use
- ❌ Two different entry points

---

## Recommended Implementation: Option 1 + Option 2

Combine query parameter selection with auto-detection for the best user experience:

1. **Auto-detect** legacy browsers by default
2. **Allow override** via `?client=modern` or `?client=legacy`
3. **Separate files** for legacy JS/CSS/templates

---

## Implementation Checklist

### Phase 1: Create Legacy Templates
- [ ] Create `templates/base_legacy.html` - ES5-compatible base template
- [ ] Create `templates/index_legacy.html` - Legacy editor page

### Phase 2: Create Legacy JavaScript
- [ ] Create `static/js/legacy/api-service.js` - Promises instead of async/await
- [ ] Create `static/js/legacy/i18n-service.js` - ES5 compatible
- [ ] Create `static/js/legacy/story-manager.js` - ES5 compatible
- [ ] Create `static/js/legacy/ui-controller.js` - ES5 compatible
- [ ] Create `static/js/legacy/app.js` - ES5 compatible entry point

### Phase 3: Create Legacy CSS (if needed)
- [ ] Create `static/css/legacy/` directory
- [ ] Add fallbacks for CSS variables (hardcoded values)
- [ ] Add `:focus` fallbacks for `:focus-visible`

### Phase 4: Update Router
- [ ] Add client detection utility
- [ ] Update `pages.py` to serve appropriate template

### Phase 5: Update Story Generator (for played stories)
- [ ] Add `client_type` parameter to compile endpoint
- [ ] Create legacy-compatible JavaScript in `templates.py`
- [ ] Generate appropriate story HTML based on client type

### Phase 6: Testing
- [ ] Add tests for client detection
- [ ] Add tests for legacy template rendering
- [ ] Manual testing with Firefox 52 ESR / Aquafox

---

## API Endpoint Changes

### Modified Endpoints

```python
# POST /api/compile
{
    "content": "...",
    "filename": "...",
    "client": "modern" | "legacy"  # NEW optional parameter
}
```

The `client` parameter tells the compiler which JavaScript syntax to use in the generated story HTML.

### No Changes Needed

All other API endpoints remain unchanged - they return JSON data that is browser-agnostic.

---

## JavaScript Feature Compatibility

### Features to Avoid in Legacy JS

| Feature | Modern | Legacy Alternative |
|---------|--------|-------------------|
| `async/await` | ✅ | Promise chains |
| `const/let` | ✅ | `var` |
| Arrow functions | ✅ | Function expressions |
| Template literals | ✅ | String concatenation |
| Object spread | ✅ | `Object.assign()` |
| Class syntax | ✅ | Constructor functions |
| `forEach` | ✅ | For loops |
| `fetch()` | ✅ | Polyfill available |

### Features Supported in Firefox 52

| Feature | Supported |
|---------|-----------|
| Promises | ✅ |
| `classList` | ✅ |
| `querySelector` | ✅ |
| CSS Variables | ✅ |
| Flexbox | ✅ |
| `addEventListener` | ✅ |

---

## Testing Strategy

### Unit Tests
```python
def test_legacy_client_detection():
    assert is_legacy_browser("Mozilla/5.0 ... Firefox/52.0") == True
    assert is_legacy_browser("Mozilla/5.0 ... Firefox/120.0") == False
    assert is_legacy_browser("Mozilla/5.0 ... Aquafox/3.0") == True
```

### Integration Tests
```python
def test_index_returns_modern_by_default(client):
    response = client.get("/")
    assert b"modern" in response.data or b"async" in response.data

def test_index_returns_legacy_with_param(client):
    response = client.get("/?client=legacy")
    assert b"legacy" in response.data
```

### Manual Testing
1. Test with modern Chrome/Firefox
2. Test with Firefox 52 ESR
3. Test with Aquafox browser

---

## Summary

The recommended approach is **API-driven client composition** using:

1. **Query parameter selection** for explicit control
2. **User-Agent detection** for automatic fallback
3. **Separate template/JS/CSS files** for clean separation
4. **Compile endpoint parameter** for generated stories

This approach:
- ✅ Does not modify existing modern code
- ✅ Uses existing API endpoints (truly API-first)
- ✅ Keeps legacy and modern code separate
- ✅ Is easy to maintain and test
- ✅ Provides explicit control for users and developers

---

## Next Steps

1. Review and approve this plan
2. Create legacy templates and JavaScript
3. Implement client detection
4. Update router and compile endpoint
5. Test with target browser (Aquafox)
